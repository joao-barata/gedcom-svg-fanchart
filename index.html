<!DOCTYPE html>
<meta charset='utf-8'>
<script src='https://wzrd.in/standalone/parse-gedcom@latest'></script>
<script src='https://cdn.rawgit.com/jackmoore/autosize/master/dist/autosize.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js'></script>
<script src='https://ariutta.github.io/svg-pan-zoom/dist/svg-pan-zoom.min.js'></script>
<style>
  * {
    box-sizing: border-box;
  }
  html, body {
    font: 300 12px/1.3 arial;
    height: 100%;
    margin: 0;
  }
  ul {
    padding: 0;
  }

  .infos {
    position: absolute;
    z-index: 2;
    height: 100%;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #fff;

    transition: opacity .5s ease, visibility 0s .5s linear;
  }
  .loaded .infos {
    opacity: 0;
    visibility: hidden;
  }

  .legend {
    display: none;
    position: absolute;
    flex-flow: column wrap;
    margin: 0 0 0 3em;
  }
  .legend.show {
    display: flex;
  }
  .legend_label {
    display: none;
    min-width: 12em;
    padding: 0 1em;
  }
  .legend_label.show {
    display: block;
  }
  .legend_label::before {
    content: '';
    padding: 0 .5em;
    margin-right: .5em;
  }

  aside {
    position: fixed;
    top: 0; bottom: 0;
    overflow: auto;
    display: flex;
    flex-flow: column;
    width: 12em;
    height: 100%;
    background-color: #fff;
    border-right: 1px solid #ddd;
    padding: 1em;
  }
  aside input,
  aside textarea,
  aside select {
    width: 100%;
    border: 1px solid #ddd;
    padding: .25em;
  }
  aside input[type=checkbox] {
    width: auto;
    margin-right: 1em;
  }
  aside label{
    padding: .5em 0;
    font-size: .8em;
  }
  aside textarea {
    resize: none;
    overflow: hidden;
  }

  main {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: auto;
    margin-left: 12em;
    position: relative;
  }
  svg {
    width: 100%;
    height: 100%;
    opacity: 1;
  }
  @media print {
    aside {
      display: none;
    }
    main {
      margin-left: 0;
    }
  }

  #title {
    text-align: center;
  }


  .empty-slice path {
    fill: #f5f5f5;
  }
  .SEX_f path {
    fill: #eee;
  }
  .SEX_m path {
    fill: #ccc;
  }

</style>
<script type="javascript/worker" id="paletteWorker">
importScripts('https://cdn.rawgit.com/gka/chroma.js/master/chroma.min.js');
importScripts('https://cdn.rawgit.com/medialab/iwanthue/master/js/libs/chroma.palette-gen.js');

self.addEventListener('message', function (e) {
  var colors = [];
  // color scale for numerical data
  if(e.data.isNum) {
    var base = chroma( Math.random()*360, 0.8, 0.3, 'hsl' ),
        colorgen = chroma.bezier(['white', base]);
    e.data.items.forEach(function (item) {
      var v = (item.val-e.data.min)/(e.data.max-e.data.min);
      colors.push(colorgen(.2+v*.8));
    });
  }
  // distinct colors for others
  else colors = paletteGenerator.generate(
    e.data.items.length, // number of colors
    function(color){ // This function filters valid colors
      var hcl = color.hcl();
      return hcl[0]>=0 && hcl[0]<=360
        && hcl[1]>=10 && hcl[1]<=50
        && hcl[2]>=60 && hcl[2]<=90;
    },
    false, // Using Force Vector instead of k-Means
    10, // Steps (quality)
    false, // Ultra precision
    'Default' // Color distance type (colorblindness)
  );
  postMessage( {tag:e.data, colors:colors} );
}, false);
</script>
<script type="application/json" id="dataStr"></script>
<script type="text/javascript">//<![CDATA[
window.onload=function(){

var data = {},
    main = document.getElementById('main'),
    chartStyle = document.getElementById('chartStyle'),
    chartLegend = document.getElementById('chartLegend');



/**
 * SETTINGS
 */



var settings = {
    generations : document.getElementById('generations'),
    originID : document.getElementById('originID'),
    rotation : document.getElementById('rotation'),
    fontSize : document.getElementById('fontSize'),
    txtSpace : document.getElementById('txtSpace'),
    genSpace : document.getElementById('genSpace'),
    palette  : document.getElementById('palette'),
    labelNbr : document.getElementById('labelNbr'),
    globalColors : document.getElementById('globalColors'),
    title : document.getElementById('titleTemplate'),
    text : document.getElementById('textTemplate'),
};
settings.originID.addEventListener('change', switchOrigin);
settings.palette.addEventListener('change', switchPalette);
settings.labelNbr.addEventListener('change', filterLabels);
settings.globalColors.addEventListener('change', updatePalette);

[].forEach.call(document.querySelectorAll('input.chartUpdate'), function(el) {
  el.addEventListener('change', updateChart);
});
[].forEach.call(document.querySelectorAll('input'), function(el) {
  el.addEventListener('change', function () {
    updateTitle();
    el.setAttribute('value', el.value);
  });
});

settings.title.addEventListener('input', function (el) {
  updateTitle();
  settings.title.innerHTML = settings.title.value;
});
settings.text.addEventListener('change', function (el) {
  updateIndivTexts();
  updateChart();
  settings.text.innerHTML = settings.text.value;
});

autosize(document.getElementsByTagName('textarea'));



/**
 * HELPERS
 */



function truncText ( str, n, useWordBoundary ){
  var isTooLong = str.length > n,
      s_ = isTooLong ? str.substr(0,n-1) : str;
  s_ = (useWordBoundary && isTooLong) ? s_.substr(0,s_.lastIndexOf(' ')) : s_;
  return  isTooLong ? s_ + '...' : s_;
}
function truncWords ( str, n, showFirstLetter, sep ){
  var splitted = str.split(' '),
      out = str;
  if (splitted.length > n) {
    out = splitted.slice(0, n).join(' ');
    out += showFirstLetter ? ' ' + splitted[n].substring(0, 1) : '';
    out += sep;
  }
  return out;
}
function radians (degrees) {
  return degrees * Math.PI / 180;
}
function setDefault (obj, def) {
  for (var key in obj) {
    if(obj[key] === undefined && def[key] !== undefined)
      obj[key] = def[key];
  }
  return obj;
}



/**
 * MAIN
 */



var dataStr = document.getElementById('dataStr');
retrieveContent();

window.addEventListener('dragover',function(e){
  e = e || event;
  e.preventDefault();
},false);
window.addEventListener('drop', function(e) {
  e = e || event;
  e.stopPropagation();
  e.preventDefault();
  var f = e.dataTransfer.files[0],
      reader = new FileReader();

  reader.onload = parseFileContent;
  reader.readAsText(f);
}, false);

function retrieveContent () {
  if(!dataStr.innerText.length) return;
  data = JSON.parse(dataStr.innerText);
}

function parseFileContent (e) {
  e = e.target.result.replace(/\r/g,'\r\n');
  data.tree = parseGedcom.parse(e);
  if(!data.tree.length) return;

  data.tags = [];
  data.indi = data.tree.filter(function (el) {
    return el.tag == 'INDI';
  }).map(parseIndividual);
  processTags();

  createPalettes();
  registerOrigin();
  updateTitle();
  updateIndivTexts();
  updateAncestors();
  updateChart();

  console.log(data);
}

function registerOrigin () {
  settings.originID.value = Math.min(data.indi.length-1, settings.originID.value);
  data.origin = data.indi[settings.originID.value];
}
function switchOrigin () {
  registerOrigin();
  updateAncestors();
  updateChart();
  if(!settings.globalColors.checked)
    updatePalette();
}

function updateChart() {

  data.usedtags = [];

  drawChart(data.ancestors, {
    rotation: radians(Number(settings.rotation.value)),
    fontSize: Number(settings.fontSize.value),
    txtSpace: Number(settings.txtSpace.value),
    genSpace: Number(settings.genSpace.value)
  });

  filterLabels();

  document.body.classList.add('loaded');

  svgPanZoom('#chart', {
    viewportSelector:'#view',
    fit:true,
    contain: true,
    center: true,
    maxZoom: 2,
    minZoom: 0.5
  });

  dataStr.innerText = JSON.stringify(data);
}



/**
 * PALETTES
 */



var blob = new Blob([
      document.querySelector('#paletteWorker').textContent
    ], { type: "text/javascript" });
var palette = new Worker(window.URL.createObjectURL(blob));
palette.addEventListener('message', addPalette, false);


function createPalettes () {
  settings.palette.innerHTML = '<option value=""></option>';
  var legends = '';
  data.tags.forEach( function(tag) {
    if (tag.items.length < 2) return;
    legends += tagLegend(tag);
    settings.palette.options[settings.palette.options.length] = new Option(tag.title, tag.name);
  });
  chartLegend.innerHTML = legends;
}
function updatePalette () {
  var currtag = settings.palette.value;
  main.className = '';
  var tag = data.tags.find(function (el) {
    return el.name == currtag;
  });
  if(!tag) return;

  if (!settings.globalColors.checked) {
    var fitems = tag.items.filter( function(item) {
      return data.usedtags.indexOf(item.cls) !== -1;
    });
    tag = {name:tag.name, items:fitems, isNum:tag.isNum, min:tag.min, max:tag.max};
  }

  if (tag.items.length < 2) return;
  palette.postMessage(tag);
}
function paletteStyle (tag, colors) {
  var style = document.getElementById('style_'+tag.name),
      styleContent = '',
      labels = '';

  if(!style) {
    style = document.createElement('style');
    style.id = 'style_'+tag.name;
    style.class = 'paletteStyle';
    style.type = 'text/css';
    document.head.appendChild(style);
  } else style.innerText = '';

  tag.items.forEach( function(item, i) {
    var color = 'rgba('+colors[i]._rgb.join(',')+')';
    // slice color
    styleContent += '.show_'+tag.name+' .'+item.cls+' path{fill:'+color+'}';
    // label square color
    styleContent += '.legend_label.'+item.cls+'::before{background:'+color+'}';
  });

  style.innerText = styleContent;
}
function addPalette(e) {
  paletteStyle(e.data.tag, e.data.colors);
  main.className = 'show_'+settings.palette.value;
}
function switchPalette () {
  updatePalette();
  updateLegend();
}
function tagLegend (tag) {
  var labGroup = '<div class="legend '+tag.name+'">';
  labGroup += '<header contenteditable>'+tag.title+'</header><ul>';
  tag.items.forEach( function(item) {
    labGroup += '<li class="legend_label '+item.cls+'" contenteditable>'+item.val+'</li>';
  });
  return labGroup + '</ul></div>';
}
function updateLegend () {
  var labGroups = chartLegend.children;
  [].forEach.call(labGroups, function(el, i) {
    if (settings.palette.value && el.classList.contains(settings.palette.value))
      el.classList.add('show');
    else el.classList.remove('show');
  });
  filterLabels();
}

function filterLabels () {
  if (!settings.palette.value) {
    return;
  }
  var elements = [],
      labels = chartLegend.querySelectorAll('.'+settings.palette.value+' .legend_label'),
      nbr = 0;

  labels.forEach( function(el, index) {
    var slicesNbr = main.querySelectorAll('g.slice.'+el.classList[1]).length;
    if ( nbr < settings.labelNbr.value && slicesNbr ){
      nbr++;
      el.classList.add('show');
      el.style.order = -slicesNbr;
      //el.innerText += '('+slicesNbr+')';
    } else el.classList.remove('show');
  });
}



/**
 * TREE PROCESSING
 */



function updateAncestors () {
  data.ancestors = [data.origin];
  for (var gen = 0; gen <= settings.generations.value; gen++)
  {
    var start = Math.floor(Math.pow(2, gen-1)),
        end = Math.pow(2, gen);

    for (var i = start; i < end; i++)
    {
      var parents = getParents(data.ancestors[i]);
      if(!parents.length) {
        data.ancestors.push({});
        data.ancestors.push({});
      } else {
        data.ancestors.push(parents[0]);
        data.ancestors.push(parents[1]);
      }
    }
  }
}
function getParents (indiv)
{
  if(indiv === undefined || indiv.tree === undefined) return [];

  // find family where indiv is child

  var indivFamilyID = indiv.tree.find(function (el) {
     return el.tag == 'FAMC';
  });
  if(indivFamilyID === undefined) return [];

  var indivFamily = data.tree.find(function (el) {
     return el.pointer == indivFamilyID.data;
  });
  if(indivFamily === undefined) return [];

  // get parents IDs of that family

  var parents = [];
  var parentA = indivFamily.tree.find(function (el) {
     return el.tag == 'HUSB';
  });
  var parentB = indivFamily.tree.find(function (el) {
     return el.tag == 'WIFE';
  });

  // get parents

  if(parentA !== undefined) {
    parents.push(data.indi.find(function (el) {
      return el.pointer == parentA.data;
    }));
  }
  if(parentB !== undefined) {
    parents.push(data.indi.find(function (el) {
      return el.pointer == parentB.data;
    }));
  }

  return parents;
}

function parseIndividual (indiv) {
  indiv.classes = [];
  indiv.SQUA = 0;
  indiv.tree.forEach(function (event) {
    switch (event.tag) {
      case 'NAME': registerName(indiv, event); break;
      case 'SOUR': registerSource(indiv, event, 'I'); break;
      case 'BIRT': registerBirthDeath(indiv, event); break;
      case 'DEAT': registerBirthDeath(indiv, event); break;
      default: registerGeneric(indiv, event); break;
    }
  });
  registerTagClass(indiv, 'SQUA', indiv.SQUA);

  return indiv;
}
function updateIndivTexts () {

  var lines = settings.text.value
    .split('\n')
    .filter(function (el, i) {
      return el.trim().length > 0;
    });

  data.indi.forEach( function(el) {
    el.texts = [];
    for (var i = 0; i < lines.length; i++) {
      el.texts.push(parseTextTemplate(lines[i], el));
    }
  });
}
function updateTitle () {
  document.getElementById('title').innerHTML = parseTextTemplate(settings.title.value, data.origin).join(' ');
}
function registerGeneric (indiv, event) {
  var exclude = ['NAME', 'FAMC', 'FAMS', 'BIRT', 'DEAT', 'EVEN', 'CHAN'];
  if (exclude.indexOf(event.tag) != -1)
    return;
  registerTagClass(indiv, event.tag, event.data);
}
function registerName (indiv, nameobj) {
  var name, last, surn,
      lastreg = /\/(.*?)\//;

  name = nameobj.data,
  last = name.match(lastreg)[1].replace(/(\s*,\s*)+/g, ' ').trim();
  name = name.replace(lastreg, '');
  surn = name.trim();

  indiv.SURN = surn;
  registerTagClass(indiv, 'LAST', last);
  surn.split(/[- ]+/).forEach(function(n) {
    registerTagClass(indiv, 'SURN', n, true);
  });
}
function registerBirthDeath (indiv, event) {
  var t = event.tag[0],
      places,
      placesKeys = ['COUNTR','STATE','DISTR','TOWN'];
  //date
  var datestr = getValue(event, 'DATE'),
      date = parseDate(datestr);
  indiv[t+'DATE'] = datestr;
  if (date !== '') {
    registerTagClass(indiv, t+'DAY', date.getDate());
    registerTagClass(indiv, t+'MON', date.getMonth()+1);
    registerTagClass(indiv, t+'YEAR', date.getFullYear());
    registerTagClass(indiv, t+'PRE', date.prefix);
  }
  //place
  var ptag = t + 'PLAC';
  indiv[ptag] = getValue(event, 'PLAC');
  if(indiv[ptag]) {
    places = indiv[ptag].split(/,\s*/, 5);
    places.reverse();
    places.forEach(function (el, i) {
      var subptag = t+placesKeys[i];
      registerTagClass(indiv, subptag, el, true);
      indiv[subptag] = el;
    });
  }
  //source
  var source = getData(event, 'SOUR');
  if(source && source.data) {
    registerSource(indiv, source, t);
  }
}
function registerSource (indiv, source, prefix) {
  prefix = prefix || '';
  var squality = Number(getValue(source, 'QUAY'));
  registerTagClass(indiv, prefix+'SOUR', source.data);
  registerTagClass(indiv, prefix+'SQUA', squality);
  indiv.SQUA += squality;
}
function registerTagClass (indiv, tagname, value, noattr) {
  if(!noattr) indiv[tagname] = value;
  var v = value;
  if(v.split) v = v.split(/[, ]/g)[0];
  var cls = tagname+cssnamify(v);
  indiv.classes.push(cls);

  var item,
      newitem = {val: v, cls: cls, nbr: 1},
      tag = data.tags.find(function (el) {
        return el.name == tagname;
      });
  if (!tag) {
    data.tags.push({ name:tagname, items:[newitem], isNum: Number(parseFloat(value)) == value });
    return;
  }

  item = tag.items.find(function (el) {
    return el.cls == cls;
  });
  if (item) item.nbr++;
  else tag.items.push(newitem);
}
function processTags () {
  data.tags.forEach( function(tag) {
    // translate
    tag.title = translateTagKey(tag.name);
    // sort tag values by occurences
    tag.items.sort(function (a, b) {
      return b.nbr - a.nbr;
    });
    // compute min/max
    if (!tag.isNum) return;
    tag.items.forEach( function(item) {
      if (!tag.max || item.val > tag.max) tag.max = item.val;
      if (!tag.min || item.val < tag.min) tag.min = item.val;
    });
  });
}
function translateTagKey (tag) {
  var t = tag.replace(/^[BDI]/, ''),
      trans = {
        evts: { B: 'Birth %', D: 'Death %', I: 'Individual %' },
        tags: {
          SEX: 'Genre', OCCU: 'Profession',
          SURN: 'Surnames', LAST: 'Lastnames',
          DAY: 'day', MON: 'month', YEAR: 'year', PRE: 'date type',
          COUNTR: 'country', STATE: 'state', DISTR: 'district', TOWN: 'town',
          SOUR: 'Source', SQUA: 'Sources quality',
          NOTE: 'Note',
        }
      },
      nocut = ['BAPL','BAPM','BARM','BASM','BIRT','BLES','BLOB','DATA','DATE','DEAT','DESC','DESI','DEST','DIV','DIVF','DSCR','IMMI','IDNO','INDI'],
      tagval = trans.tags[t],
      event = trans.evts[tag[0]],
      val = (tagval && event && !~nocut.indexOf(tag)) ? event.replace(/%/, tagval) : tagval;
  return tagval ? val : tag;
}

function getData (node, tag) {
  if(!node || !node.tree) return '';
  return node.tree.find(function (el) {
     return el.tag == tag;
  });
}
function getValue (node, tag) {
  var result = getData(node, tag);
  if(result === undefined) return '';
  return result.data;
}
function cssnamify(str) {
  if(str.trim) {
    str = str.trim()
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,"") // diactritics
      .replace(/[^a-z0-9]/g, function(s) {
        var c = s.charCodeAt(0);
        if (c == 32) return '-';
        return '';
      });
  }
  return '_' + str;
}

function parseDate(inp) {
  var date, str, prefix = '';
  // remove ranges
  str = inp.trim()
    .replace(/(?:FROM|BET)\s*/,'')
    .replace(/\s*(?:TO|AND).+/,'');
  if(!str.length)
    return '';
  // extract additional info
  str = str.split(/(ABT|CAL|EST|AFT|BEF)/);
  if(str.length > 1) {
    prefix = str[1].toLowerCase() + '.';
    str = str[2];
  } else str = str[0];
  date = new Date(str);
  date.prefix = prefix;
  return date;
}



function parseTextTemplate (str, indiv)
{
  var keyreg = /([A-Z]{3,}(?:\.*\d+)?)/g;
  str = str.split(keyreg).map( function(key) {
    if(!key.match(keyreg))
      return key;

    var truncnbr,
        truncate = /([A-Z]{3,})(\.*)(\d+)/g.exec(key);
    if(truncate !== null) {
      key = truncate[1];
      truncnbr = Number(truncate[3]);
    }

    if(key == 'GENS') return settings.generations.value;

    if(!indiv.hasOwnProperty(key))
      return '';

    if(Array.isArray(indiv[key]))
      text = indiv[key].join(' ');
    else text = indiv[key];

    if(truncate !== null) {
      switch (truncate[2]) {
        case '...': text = truncText(text, truncnbr, false); break;
        case '..': text = truncWords(text, truncnbr, false, '...'); break;
        case '.': text = truncWords(text, truncnbr, true, '.'); break;
        default: text = truncWords(text, truncnbr, false, ''); break;
      }
    }
    return ' ' + text;
  });
  return str;
}



/**
 * CHART
 */



function maxTextsSizes (indivs, start, end, options) {
  var maxLength = 0,
      charWidth = options.fontSize * 0.4,
      setMaxLength = function(el) {
        var len = el.join(' ').length;
        if (len > maxLength)
          maxLength = len;
      };
  for (var i=start; i<end; i++) {
    if(indivs[i] && indivs[i].texts)
      indivs[i].texts.forEach(setMaxLength);
  }
  return {
    width: maxLength * charWidth + options.txtSpace,
    height: indivs[0].texts.length * options.fontSize + options.txtSpace
  };
}
function sliceMaxLines (texts, slice) {
  // mesure the smallest arc size (not rooted)
  // and return how much lines heights get in
  var x = slice.arc1.a.x - slice.arc1.b.x,
      y = slice.arc1.a.y - slice.arc1.b.y,
      size = x*x + y*y,
      lineh = settings.fontSize.value;
  return Math.min(texts.length, Math.round(size / (lineh*lineh)));
}
function slicePathCoordinates (start, angle, r, t, reverse) {
  var arc1 = arcCoordinates(start, angle, r, reverse),
      arc2 = arcCoordinates(start+angle, -angle, r + t, reverse);
  return reverse ? { arc1:arc2, arc2:arc1 } : {arc1:arc1, arc2:arc2};
}
function arcCoordinates (start, angle, r, reverse) {
  if(reverse) {
    start = start+angle;
    angle *= -1;
  }
  return {
    r : r,
    a : {
      x : Math.cos(start) * r,
      y : Math.sin(start) * r
    },
    b : {
      x : Math.cos(start+angle) * r,
      y : Math.sin(start+angle) * r
    }
  };
}
function arcPath (start, angle, r, reverse) {
  var c = arcCoordinates(start, angle, r, reverse),
      arcdir = reverse ? '0,0' : '0,1';
  return " M"+c.a.x+","+c.a.y + " A"+r+","+r+" 0 "+arcdir+" "+c.b.x+","+c.b.y;
}

function drawChart (individuals, options) {

  options = setDefault(options, {
    rotation: radians(90),
    genSpace: 1,
    txtSpace: 10,
    fontSize: 7
  });

  var radius = 30,  // center radius
      thickness,
      snap, view, fan, slice, // snapsvg objects
      coord, slicePath,
      lineCoord, linePath, lineNbr, spliceWidth,
      textAttrs = {
        fontSize: options.fontSize,
        textAnchor: 'middle'
      };

  snap = Snap('#chart');
  view = snap.select('#viewport');
  fan = snap.select('#fan');

  var addTextLine = function(text, index) {
    if(index+1 > lineNbr) return;
    textAttrs.dy = (index+1) * options.fontSize - lineNbr*(0.5*options.fontSize);
    slice.text(0,0, text )
         .attr(textAttrs)
         .textPath.attr({startOffset: '50%'});
  };

  if(fan !== null)
    fan.remove();
  fan = view.g().attr({id: 'fan'});

  var id = 0;
  for(var gen=1; gen<=settings.generations.value; gen++)
  {
    var isHorizontal = gen < 4;
    var arcsNbr = Math.pow(2, gen);
    var arcAngle = 2*Math.PI / arcsNbr;
    var maxTexts = maxTextsSizes(individuals, id, id+arcsNbr, options);

    thickness = isHorizontal ? maxTexts.height : maxTexts.width;

    for(var sliceID=0; sliceID<arcsNbr; sliceID++)
    {
      var startAngle = arcAngle * sliceID + options.rotation;
      var middleAngle = startAngle + arcAngle * 0.5;
      var isTopHalf = middleAngle >= Math.PI && middleAngle <= Math.PI*2;
      var isLeftHalf = middleAngle >= Math.PI/2 && middleAngle < Math.PI * 1.5;
      var reverse = (isHorizontal && isTopHalf) || (!isHorizontal && isLeftHalf);

      // slice

      coord = slicePathCoordinates(startAngle, arcAngle, radius, thickness);

      slicePath  = " M"+coord.arc1.a.x+","+coord.arc1.a.y;
      slicePath += " A"+coord.arc1.r+","+coord.arc1.r+" 0 0,1 "+coord.arc1.b.x+","+coord.arc1.b.y;
      slicePath += " L"+coord.arc2.a.x+","+coord.arc2.a.y;
      slicePath += " A"+coord.arc2.r+","+coord.arc2.r+" 0 0,0 "+coord.arc2.b.x+","+coord.arc2.b.y;
      slicePath += " Z";

      slice = fan.g();
      slice.addClass('slice GEN_'+gen);
      slice.path(slicePath);

      // related individual
      id++;
      var indiv = individuals[id];
      if(indiv === undefined || indiv.tree === undefined) {
        slice.addClass('empty-slice');
        continue;
      }
      slice.addClass(indiv.classes.join(' '));
      data.usedtags.push.apply(data.usedtags, indiv.classes);

      // texts

      if (isHorizontal) {
        // centered horizontal arc
        textAttrs.textpath  = arcPath(startAngle, arcAngle, radius + thickness * 0.5, !reverse);
      } else {
        // centered vertical line
        lineCoord = slicePathCoordinates(startAngle+arcAngle*0.5, 0, radius, thickness, reverse);
        textAttrs.textpath = "M"+lineCoord.arc1.a.x+","+lineCoord.arc1.a.y+" "+lineCoord.arc2.a.x+","+lineCoord.arc2.a.y;
      }
      lineNbr = isHorizontal ? indiv.texts.length : sliceMaxLines(indiv.texts, coord);
      indiv.texts.forEach(addTextLine);
    }
    radius += thickness + options.genSpace;
  }
}

};//]]>

</script>
<body>
<div class="infos">Drop a GEDCOM file</div>
<aside class="controls">
  <label>title<textarea id="titleTemplate">Ascendants fan chart of SURN LAST<br>GENS generations</textarea></label>
  <label>generations<input type="number" id="generations" class="chartUpdate" min="1" max="10" value="6"></label>
  <label>origin ID<input type="number" id="originID" min="0" max="9999" value="0"></label>
  <label>content<textarea id="textTemplate">SURN.1 LAST2
BYEAR - DYEAR
OCCU</textarea></label>
  <label>rotation<input type="number" id="rotation" class="chartUpdate" min="0" max="360" step="45" value="90"></label>
  <label>font size<input type="number" id="fontSize" class="chartUpdate" min="5" max="20" step="1" value="7"></label>
  <label>padding<input type="number" id="txtSpace" class="chartUpdate" min="0" max="50" step="10" value="10"></label>
  <label>generation spacing<input type="number" id="genSpace" class="chartUpdate" min="0" max="20" step="1" value="1"></label>
  <label>color palette<select id="palette"></select></label>
  <label>legend labels<input type="number" id="labelNbr" min="0" value="10"></label>
  <label><input type="checkbox" id="globalColors" checked>global coloring</label>
</aside>
<main id="main">
  <h3 id="title"></h3>
  <div id="chartLegend"></div>
  <svg id="chart"><g id="viewport"></g></svg>
</main>
